// JS - мова програмування з динамічною типізацією, високорівнева, інтерпретована, мультипарадигмова, скриптова

// JS виконується браузером (движком)

// стандарт ECMAScript

// функція для виведення повідомлелння через модальне вікно на сторінці браузера
// alert("Hello world!");

// функція для виведення даних в консоль (в інструментах розробника) 
// console.log("Hi!");

// clo - скорочення для швидкого набору консоль лога з виведенням і стрінга object :>> і значення в змінній в консоль
// console.log('object :>> ', object);
// clg - скорочення для швидкого набору консоль лога з виведенням значення що міститься в змінній в консоль
// console.log(object);


// // - це однорядковий коментар
// /* */ - це багаторядковий коментар




        // Змінні


    // - let це змінна , значення якої можна змінювати (не строге)
    // - перше присвоєння називається ініціалізація
    // - назви змінних, функцій, тощо пишемо в lowerCamelCase (перша буква маленька, далі кожне наступне слово з великої, без пробілів)
    // - класи,тощо пишемо в UpperCamelCase (перша буква велика, далі кожне наступне слово з великої, без пробілів)
    // - константи пишемо в UPPER_SNAKE_CASE (всі будки великі, слова розділені нижнім підчеркуванням)
    // можна використ наст символи: a-z, A-Z, _, $, 0-9 - для першої літери неможна використ цифри

// let userName = 'Anrietta';
// console.log(userName);  // - виведе лише значення Anrietta
// // console.log('userName :>> ', userName); - виведе назву змінної + значення
// userName = 1;
// console.log(userName);

//     // - const це змінна , значення якої НЕ можна змінювати (строге)
//     // для уникнення випадкової зміни значення, всі змінні які не мають змінюватись, рекомендується оголошувати як const
//     // const рекомендовано використовувати коли ми самі розуміючи контекст коду та задачі знаємо що ми ці значення не будемо змінювати в своєму скрипті (для циклів, функцій, перевизначення значення в зміній тощо)


// // const constValue = 10;
// // constValue = 5;  // Не дозволяє змінювати значення
// // console.log(userName);


//     // - var це змінна , значення якої можна змінювати (Вони устарівші , їх не використовувати!)
// var anotherValue = 'string';



// // ##############################################################################################################################################


//         // Типи даних


// // Динамічна типізація - це зміна типу даних саме в процесі виконання коду
// // в інших мовах програмування (типізованих) - тип даних задається явно разом з оголошенням зміннної, тобто самій змінній присвоюється певний тип даних
// // в JS (не типізований) - тип даних визначається не змінній а значенню змінної (за допомогою додаткових символів чи значень), і в майбутньому цей тип може бути змінений будь якою частиною коду
// // в JS існує 8 типів даних, з них 7 перших примітивні типи даних, 1 останній це складний тип

// // Типи даних JS:

// // string: 'value', "value", `value` - рядок, текстові дані
//     const stringVar1 = 'value';
//     console.log(stringVar1);
//     console.log(typeof(stringVar1));
//     console.log('store "Aliexpress"'); //-якщо нам потрібно в стрінг вкласти текст огорнутий в лапки, то треба для того шматка тексту просто використати будь-які інші лапки крім тих які викорситовуються для коді
//     console.log('store \'Aliexpress\''); //ще можна використати символ екранування \ 



// // number: 
//     // 4, 0, -10 - цілі числа; 
//     // 20.5, -0.5 - з фіксованою крапкою; 
//     // 0.4e25 = 0.4*10^25 = 0.00000000000000000000000004 - 0,4 * 10 піднесений в 25 степені, для запису довжелезних чисел (^-піднесення о степеня) - з плаваючою комою (експоненційна форма)
//     // 21e16 = 21*10^16 = 210000000000000000  - з плаваючою комою (експоненційна форма)
//     // NaN - not a number - помилка з типом даних Number
//     // 5/0 - ділити на нуль неможна, як результат операції отримаєм Infinity або -Infinity
//     // -0 -  малесеньке число дуууже сильно близьке до 0 з відємним значенням
//     // +0 - малесеньке число дуууже сильно близьке до 0 з додатнім значенням
//         const a = 10.002;
//         console.log(a);
//         console.log(typeof(a));

//     // Number.MAX_SAFE_INTEGER - максимальне ціле число
//     // Number.MAX_VALUE - максимальне числове значення




// // bigint - велике ціле число. В кінці значення дописуєм n це ми позначили число як дуже велике,і JS дозволить вивести його в такому вигляді, тобто значення явно більше ніж дозволено Number.MAX_SAFE_INTEGER і ми про це повідомляємо
//         const bigintValue = 1111111111111111111111111111111111111n;
//         console.log(bigintValue);




// // boolean: true (+), false (-) - логічні значення
//     // назву змінної прийнято починати з is
//         const isOdd = false;
//         console.log(isOdd);
//         console.log(typeof(isOdd));




// // null: - окремий тип даних (хоча має тип даних object, це баг який не фіксять бо все поламаться), що означає що змінна пуста, сама змінна є, а вній нема значення
//     // як порожня коробка з повітрям, нічого
//     const nullValue = null;
//     console.log(nullValue);
//     console.log(typeof(nullValue));



// // undefined - тип даних undefined, що означає що змінна взагалі немає задеклованого нічого, вона як оголошена але їй не присвоєно навіть "нічого/пустого знач"
//     // як порожня коробка навіть без повітря, вакуум
//     let value;
//     console.log(value);
//     console.log(typeof(value));



// // symbol - використ рідко, восновному для технічних речей, генерує завідомо унікальні значення,але переглянути їх не дає
//     const symbolValue = Symbol();  // згенерує щось схоже на це vd1fv2v1vdvsf2vsfv1vd5v7vs5svsv599vr - щось схоже на Хеш коміта
//     console.log(symbolValue);



// // object - грубо кажучи це контейнер що може вміщувати будь які примітивні типи даних
//     const objValue = {};
//     console.log(objValue);
//     console.log(typeof(objValue));


// // ########################################################################################################################


// // Визначення типу даних

// // typeof() - використовується для отримання інфи про тип даних
//     // console.log('typeof 10 :>> ', typeof 10);
//     // typeof 10 :>>  number  - результат виведений в консоль
//     console.log('typeof 11n :>> ', typeof 11n);  //typeof 11n :>>  bigint
//     console.log('typeof "11n" :>> ', typeof "11n");  //typeof "11n" :>>  string
//     console.log('typeof true :>> ', typeof true); //typeof true :>>  boolean
//     console.log('typeof "true" :>> ', typeof "true"); //typeof "true" :>>  string
//     console.log('typeof null :>> ', typeof null); //typeof null :>>  object
//     console.log('typeof undefined :>> ', typeof undefined); //typeof undef :>>  undefined
//     console.log('typeof objValue :>> ', typeof objValue); //typeof objValue :>>  object


// // ###############################################################################################################################


// // Задачка: 
// // задати дві змінні: 
// // своє їм'я і кількість років і вивсести ці знач в консоль

// const userName1 = 'Anrietta';
// let userAge = 35;
//     console.log('userName1 :>> ', userName1);
//     console.log('userAge :>> ', userAge);



// // ##############################################################################################

//         // Операції 

// //Операції

// let b = 10; //- операція присвоювання, перше присвоювання називається - ініціалізація
// b = 0; //- оперція присвоювання, змінюємо значення змінної

// //Арифметичні : + - * / % **

// let c = 1 + 2;
// console.log(c); // 3 

// let d = 5 + 8;
// console.log(d);

// let e = 5 - 8;
// console.log(e);

// let f = 5 * 8;
// console.log(f);

// let g = 10 / 2;
// console.log(g);

// let h = 10 % 3;  // остача від ділення
// console.log(h);

// let i = 10**2;  // піднесення до степеню
// console.log(i);

// // JS при обчисленні дробів допускає похибку в підрахунках 0,2 * 0,1 = 0,30000000000000004

// // Math. - містить додаткові функції та константи для склданих обчислень

// console.log(Math.sqrt(100));  // функція для обчислення квадратного кореня
// console.log(Math.pow(5, 2));  // функція приведення до степеня

// const r = 10;  // радіус кола
// const j = 2 * Math.PI * r; // функція число Пі для обчислення довжини кола
// console.log(j);  


// console.log(4 + 8 * 0.1); // операції виконаються як в математиці, спершу * / потім + -, якщо тре змінити пріоритет використовуєм в ()
// console.log(2 ** 3 ** 2);  // 52 бо піднесення до степеня рахується зправа на ліво




// Операції для рядків

// Конкатенація - склеювання рядків 'str1' + 'str2' => 'str1str2'

// const greeting = 'You are ';
// const age = prompt('How old are you?', '');
// console.log(greeting + age + ' years old!');

// console.log("1" + 1);  // 11 рядок



// // Скорочені операції : +=, -=, *=, /=, ...
// let sum = 5;
// // sum = sum + 5; // довгий запис
// sum += 5;       // короткий запис попереднього рядка
// console.log(sum);
// // sum = sum * 10; // довгий запис
// sum *= 10;      // короткий запис попереднього рядка
// console.log(sum);



// Інкремент - increase - збільшити на 1
//Ще суперскорочення щоб додати 1, тільки одницю (використ в циклах)

// Інкремент постфіксний:
// sum += 1; 
// sum++;

// let x = 10;
// const y = x++;  // ця операція повертає себе ДО збільшення а потім збільшується
// console.log(y); //10
// console.log(x); //11


// Інкремент префіксний:
// let x1 = 10;
// const y1 = ++x1;  // ця операція спершу збльшується а потім повертає себе після збільшення
// console.log(y1); //11
// console.log(x1); //11

// Декременти префіксний та постфіксний
// Декремент - decrease - зменшувати
// --x , x--


// ######################################################################################################################


        // Приведення типів (Type conversion)

// Ввести два числа і вивести їх суму:

// const a1 = prompt('Введіть перше число:');  // функція prompt по замовчуванню приймає рядок і повертає рядок, навіть якщо там ввели число, тбто sum1 в нам поверне не 100+100=200 а поверне зконкатинований рядок '100'+'100='100100'
// const a2 = prompt('Введіть перше число:');
// const sum1 = a1 + a2;
// console.log(sum1);


//Явне приведення типів:
// щоб отримати очікуваний результат, потрібно вкзаати одразу тип даних:

// result = Number(10);  // значення буде числом
// const res1 = Number('10'); // значення буде числом 10
// const res2 = Number(null); // значення буде числом 0

// const res3 = String(5); //результат буде рядком '200'
// const res4 = String(undefined); //результат буде рядком 'undefined'

// Ввести 2 числа і вивести їхню суму 2:
// const op1 = Number(prompt('Введіть перше число:'));
// const op2 = Number(prompt('Введіть друге число:'));
// const sum2= op1 + op2;
// console.log(sum2);


//Те саме лиш коротший запис, + = Number
// const op1 = +prompt('Введіть перше число:');
// const op2 = +prompt('Введіть друге число:');
// const sum2= op1 + op2;
// console.log(sum2);


//Ввести три числа і порахувати їх добуток
// const op1 = +prompt('Введіть перше число:');
// const op2 = +prompt('Введіть друге число:');
// const op3 = +prompt('Введіть третє число:');
// const sum4 = op1 * op2 * op3;
// console.log(sum4.toFixed(2));  //.toFixed() - функція яка обрізає зайві цифри в числі до тої кількості символів які ми вкажем в дужках, але виводитись буде стрінг, вона число перетворить в стрінг



// Неявне приведення типів -  варто уникати всюди де можна

// console.log("10 + '10' :>>" , 10 + '10');  // 1010 стрінг
// console.log("null + '10' :>>" , null + '10'); // null10 стрінг
// console.log("null + '10' :>>" , null + '10'); // null10 стрінг




// #####################################################################################################################


                // Умовний оператор IF

// if - розгалуження:

// if (умова) {           // якщо умова виконується то виконається те що в if - тобто результат буде true
//         гілка true;
// } else {                 // якщо умова в if не виконується то виконається те що в else - тобто результат буде false
//         гілка false;
// }

// {} - фігурні дужки ще називають операторні дужки

// const isLogged = false;

// if (isLogged) {
//         console.log('Вітаємо, ви успішно увійшли в систему');
// } else {
//         console.log('Спробуйте ввети свої дані повторно');
// }


// Задачка

// задати змінну чи достатньо грошей
// Якщо грошей достатньо, вивести "Операцію схвалено"
// Якщо грошей не достатньо, то вивести "Операцію відхилено"

// const isEnoughMoney = true;

// if (isEnoughMoney) {
//         console.log('Операцію схвалено');
// } else {
//         console.log('Операцію відхилено');
// }


// Оператори порівняння:

// age > 18,
// age < 18,
// age >= 18,
// age <= 18,
// age == 18,   // дорівнює без врахування типу даних (не строге порівняння / вміє перетворювати типи)
// age === 18,  // дорівнює в т.ч. й тип даних (строге порівняння / не вміє перетворювати типи)
// age != 18,   // не дорівнює без врахування типу даних (не строге порівняння / вміє перетворювати типи)
// age !== 18   // не дорівнює в т.ч. й тип даних (строге порівняння / не вміє перетворювати типи)


// console.log(10 == '10'); //true
// console.log(10 == 10); //true

// console.log(10 === 10); //true
// console.log(10 === '10'); //false

// console.log(10 != '10'); // false - бо без врахувння типу вони рівні
// console.log(10 != 10); // false - бо вони рівні

// console.log(10 !== '10'); //true - бо вони нерівні враховуючи тип
// console.log(10 !== 10); // true - бо вони рівні враховуючи тип



// Задачка

// Якщо користувач повнолітній, то привітати. якщо ін - то доступ заборонено

// const age = Number(prompt('Скільки Вам років?'));

// if (age >= 18) {
//         console.log('Вітаємо на порталі послуг!');
// } else {
//         console.log('Вибачте, доступ заборонено!');
// }


//Задачка

// Ввести два числа і знак операції. 
// Якщо введено + то порахувати і видати суму цих двох чисел
// Інакше вивести їхню різницю

// const a = Number(prompt('Введіть перше число:')),
//         b = Number(prompt('Введіть друге число:')),
//         c = prompt('Введіть оператор:');

// if (c === '+') {
//         console.log('Сума чисел:', a + b);
// } else {
//         console.log(`Сума чисел: `+ (a - b));
// }




// Скорочена форма if (без else)

// Задачка
//Вивести привітання для користувачів сайта
//Але якщо користувач неповнолітній то попередити його про обмеження доступу

// const age = Number(prompt('Скільки Вам років?'));

// if (age < 18) {
//         console.log('Вибачте вам обмежено доступ!');
// }
// console.log('Вітаємо на нашому ресурсі!');



// Розширена форма if (else if)

// Ввести два числа і знак операції. 
// Якщо введено + то порахувати і видати суму цих двох чисел
// Якщо введено * то порахувати і видати добуток цих двох чисел
// Інакше вивести їхню різницю

// const a = Number(prompt('Введіть перше число:')),
//         b = Number(prompt('Введіть друге число:')),
//         c = prompt('Введіть оператор:');

// if (c === '+') {
//         console.log('Сума чисел:', a + b);
// } else if (c === '*') {
//         console.log('Добуток чисел:', a * b);
// } else {
//         console.log(`Різниця чисел: `+ (a - b));
// }


// ##########################################################################################################


                // Логічні (булевські) оператори ТА чи АБО (AND vs. OR)

// && - AND, оператор ТА - відповідність всім умовам (дає істину тоді коли всі умови істина)
// || - OR, оператор АБО - відповідність хоча б одній з умов (дає істину тоді коли хоча б одна з умов істина)
// !умова  - НЕ умова


// console.group('Таблиця істинності &&:');

// console.log('true && true :>> ', true && true); // => true, якщо всі true
// console.log('false && false :>> ', false && false); // false
// console.log('true && false :>> ', true && false);  // false
// console.log('false && true :>> ', false && true); // false

// console.groupEnd();

// console.group('Таблиця істинності ||:');

// console.log('true || true :>> ', true || true); // true
// console.log('false || false :>> ', false || false); // => false, якщо всі false
// console.log('true || false :>> ', true || false); // true
// console.log('false || true :>> ', false || true); // true

// console.groupEnd();

// console.group('Таблиця істинності !:');

// console.log('!true :>> ', !true); // false
// console.log('!false  :>> ', !false); // true

// console.groupEnd();

// істина - не істина true - false
//істинний - не істинний truly - falsy

// falsy :  0, '', false, null, undefined, NaN  =  false
// truly : 123, 'adc', true, object  = true


// const q = true;
// // if (q !== '' && q !== undefined && q!== null) {    // - довгий варіант щоб перебрати всі не істинні умови
// if (q) {                                              // - короткий варіант, якщо значення q істинне і може бути істиною (тото не відповідати умовам false) то виконати умову, бо рядок, число, обєкт це істинні значення
//         console.log('Значення коректне');
// }


// Якщо сумніваємось що істина а що не істина можна в консолі отак Boolean(123), Boolean('')...



// Задачка
// надати знижку якщо день пятниця і число 13

// const day = 'friday';
// const date = 10;

// if (day === 'friday' && date === 13) {
//         console.log('Вітаємо, ви отримали знижку 13%!');
// }


// Задачка
//Якщо не повнолітній то вивести інфо про обмеження

// const isAdult = undefined;

// if (!isAdult) {
//         console.log('Вибачте, вам надано обмежений доступ!');
// }

//нижні два варіанта написання не дуже добре використовувати, краще перший
// if (isAdult !== true) {
//         console.log('Вибачте, вам надано обмежений доступ!');
// }

// if (isAdult === false) {
//         console.log('Вибачте, вам надано обмежений доступ!');
// }


// ЗАПАМ'ЯТАТИ!!!

// NaN - це єдине значння в JS яке ніколи не дорівнює собі самому, можливо тому, що NaN утворюється з різних комбінацій типів даних при проведенні операції з числом
// NaN === NaN // false
// NaN == NaN // false
// NaN !== NaN  // true

// Щоб перевірити чи значення NaN треба використовувати функцію Number.isNaN(NaN)
// Є глобальна функція isNaN() - перевіряє чи будь які значення є чи не є NaN
// є функція Number.isNaN() - перевіряє чи число є чи не є NaN


// ####################################################################################################

                // Цикли while, do...while (Loops)


//while - цикл з передумовою, спершу перевіряємо умову потім виконуємо тіло цикла

// while (умова) {
//         тіло циклу
// }

// let sideCount = 1;  // змінна яка буде збільшуватись, лічильник
// const TOTAL_SIDE_AMOUNT = 4;  // константа в якій загальна кількість сторін (ітерацій)

// while (sideCount <= TOTAL_SIDE_AMOUNT) {  // умова, коли sideCount буде = 4, після цього цикл закінчиться (кількість ітерацій в цьому циклі = 4)
//         console.log('Пройти прямо');
//         console.log('Повернути наліво');
//         sideCount++; // sideCount += 1; sideCount = sideCount + 1;  // після виконання тіла циклу збільшити sideCount на 1
// }


//Задачка
// У користувача є книга з TOTAL_PAGE_AMOUNT сторінок
// Вивести номери сторінок від 1 до останньої

// let pageCount = 1;
// const TOTAL_PAGE_AMOUNT = 15;

// while (pageCount <= TOTAL_PAGE_AMOUNT) {
//         console.log('Page number : ' + pageCount);
//         pageCount++;
// }


// Задачка
// Вивести тільки парні сторінки

// let pageCount = 1;
// const TOTAL_PAGE_AMOUNT = 15;

// while (pageCount <= TOTAL_PAGE_AMOUNT) {
//         if (pageCount % 2 === 0) {
//                 console.log('Page number : ' + pageCount);
//         }
//         pageCount++;
// }

// Задачка
// Вивести числол і вивести його квадрат
// Перевірити, щоб число було скінченним (не NaN, Infinity)

// 1 - ввести число
// 2- якщо воно скінченне, тоді вивсети його квадрат
// 3 - якщо не підходить то перейти на перший пункт

// let n = Number(prompt('Enter number :'));

// while (!Number.isFinite(n)) {       // .isFinite - це функція Number, яка перевіряє чи число скінченне, тобто не дорівнює NaN чи Infinity
//         n = Number(prompt('Enter number :'))
// }
// console.log(n, n * n);



//do ... while - спочатку відпрацьовує цикл, а потім перевіряється умова (цикл з  постумовою)

// do {
//         тіло циклу
// } while (умова)

// let n = null;

// do {
//         n = Number(prompt('Enter number :'))
// } while (!Number.isFinite(n));

// console.log(n, n*n);


// Задачка
//Вивсети кількість торінок через do...while

// let currentPage = 0;
// const TOTTAL_PAGE_AMOUNT = 10;

// do {
//         currentPage++;
//         console.log(currentPage);
// } while (currentPage < TOTTAL_PAGE_AMOUNT);


//Задачка
//Порахувати суму чисел від 1 до 20

// let i = 1;
// let sum = 0;  // змінна акумулятор, тому що вона акмулює значення

// while (i <= 20) {
//         sum = sum + i;
//         i++;
// }
// console.log(sum);

// 1 - i = 1
// 2 -  i=1 <=20 - true
// sum = 0 + 1 = 1
        // i = i + 1 = 1 + 1 = 2
// 3 - i=2 <=20 - true 
// sum = 1 + 2 = 3
        // i = i + 1 = 2 + 1 = 3
//...
// 4 - i=20 <= 20 - true
// sum = 190 + 20 = 210
        // i = i + 1 = 20 + 1 = 21
// 5 - i=21 <= 20 - false
// 6 - виходимо з циклу


//Задачка
//Порахувати добуток чисел від 1 до 10

// let i = 1;
// let sum = 1;

// while (i <= 10) {
//         sum = sum * i;
//         i++;
// }
// console.log(sum);


// #####################################################################################################

                // Цикли FOR (Loops)


// for (початкове значення; умова-продовження; зміна лічильника) {
//       тіло циклу  
// }


//Задачка
// У користувача є книга з TOTAL_PAGE_AMOUNT сторінок
// Вивести номери сторінок від 1 до останньої

// const TOTAL_PAGE_AMOUNT = 15;

// //                0                    1                        3
// for (let currentPage = 1; currentPage <= TOTAL_PAGE_AMOUNT; currentPage++) {
// //                        2
//         console.log('Page number : ' + currentPage);
// }

// 0 - Ініціалізація лічильника,     виконується 1 раз до циклу
// 1 - умова продовження циклу       якщо умова істинна, то виконуємо тіло циклу 2, інакше вихід
// 2 - тіло циклу,                   виконується, якщо умова 1 істинна
// 3 - зміна лічильника              виконується після кожної ітерації, потім перехід на 1


//Вивести парні числа від 10 до 20 (+2)

// for (let i = 10; i <= 20; i = i + 2) {
//         console.log(i);
// }

// Вивести десятки від 0 до 100 (+10)

// for (let i = 10; i <= 100; i += 10) {
//         console.log(i);
// }

//Вивести всі числа від 5 до -5 з інтервалом в 0.5 

// for (let i = 5; i >= -5; i -= 0.5) {
//         console.log(i);
// }

//------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Змінні let i const які оголошені в середині циклу мають блочну(локальна) область видимості, тобто вони діють лише в межах циклу
//тому для різних циклів можна оголошувати змінну let i = ..., бо за межами самого циклу їх не видино
//А ті змінні які оголошені поза межами циклу мають глобальну область видимості, вони діють як ззовні в коді так і в середині будь якого циклу чи функції

// змінна var перестала використовуватись в JS. тому що в неї не було цього розподілу на глобальну і блочну зону видимості, що було дуже не зручно

// В devtools - Sources - Scope можна перевірити область видимості змінних
// Областей видимості є всього три:
// 1- Global - це глобальна область видимості всіх скриптів що підключені до сторінки
// 2- Script - це глобальна область видимості поточного скрипта що не засунуті в цикли чи функції
// 3- Block - це блочна область видимості (локальна), тобто та що знаходиться в середині циклу чи функції

// Пріоритет виглядає отак:
// Block >> Script >> Global
// тобто блок бачить все назовні і скрипт і глобал, скрипт бачить лише глобал а в блок не бачить, глобал бачить сам себе а скрипт і блок не бачить

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------


//Знайти середнє арифметичне непарних чисел від 3 до 13 (3+5+7+9+11+13) / 6

// let sum = 0;   // додаємо кожне непарне сумуючи їх
// let cuantity = 0;  // рахуємо кількість ітерацій щоб отримати кількість чисел щоб знайти середнє арифметичне
// debugger;  // можна покласти тут в коді дебагер і оновти сторінку, замість того щоб в devtools 
// for (let i = 3; i <= 13; i+=2) {
//         sum += i; // sum = sum + i
//         cuantity++;
// }
// console.log(sum / cuantity);  // суму всіх чисел ділим на кількість всіх чисел


// Порахувати добуток чисел від -5 до 10

// let sum = 1;

// for (let i = -5; i <= 10; i++) {
//         sum *= i;
// }
// console.log(sum);  // -0




//------------------------------------------------------------------------------------------------------------

                // Підсумуємо інформацію по всім трьом типам циклів

//===============
// передумова; min 0 - кількість ітерацій
// while (condition) {
//         loop body
// }

//===============
// передумова; min 0 - кількість ітерацій
// for (initialization; condition; var_change) {
//         loop body
// }


//===============
// постумова; min 1 - кількість ітерацій
// do {
//         loop body
// } while (condition)



//===================
// break; - завершити цикл
// continue; - завершити поточну ітерацію і  перейти до наступної, при цьому з циклу ми не виходимо



// ################################################################################################################

                // Шаблонні літерали (Template literals)

// Шаблонний літерал - спосіб формування рядка таким чином, щоб всередині рядка можна було використати якісь вирази

// const summand1 = 4;
// const summand2 = 5;
// Довгий варіант писати через конкатинацію щоб отримати вираз 4 + 5 = 9
        // console.log(String(summand1) + '+' + String(summand2) + '+' + '=' + String(summand1 + summand2)); 

// Шаблонний літерал - це короткий варіант написати те що вгорі. Позначається через бектики
        // console.log(`${summand1} + ${summand2} = ${summand1 + summand2}`);



//Задачка
// const greeting = 'Hello';
// const userName = prompt('Enter your name: ');

// console.log(`${greeting}, ${userName}!`);  // 'Hello, Name!' by template literal


//Задачка
//Користувач має три спроби ввести парроль
// Якщо пароль вірний, то вивести "Пароль вірний"
//Інакше "Пароль невірний"


// 1 варіант рішення роздутий класичний

// const TRY_LIMIT = 3;
// const PASSWORD_PATTERN = 'qwerty';

// let currentTry = 1;
// let password = '';

// do {
//         password = prompt('Input password: ');
//         if (password === PASSWORD_PATTERN) {
//                 break;
//         }
//         currentTry++;
// } while (currentTry <= TRY_LIMIT);

// if (password === PASSWORD_PATTERN) {
//         console.log('Password is correct!');
// } else {
//         console.log('Pasword is incorrect!');
// }


// 2 варіант рішення оптимізований короткий і красівий (ще коротший в розділі тернарний оператор)

// const TRY_LIMIT = 3;
// const PASSWORD_PATTERN = 'qwerty';

// let currentTry = 1;
// let isPasswordCorrect = false;

// do {
//         isPasswordCorrect = prompt('Input password: ') === PASSWORD_PATTERN;

// } while (++currentTry <= TRY_LIMIT && !isPasswordCorrect);

// if (isPasswordCorrect) {
//         console.log('Password is correct!');
// } else {
//         console.log('Pasword is incorrect!');
// }


// ########################################################################################################################


                // Тернарний оператор ?: (Ternary Operator)

// a++ = один операнд (унарний операнд)
// a+b = два операнди (бінарний операнд)
// a*b^2 = три операнди (тернарний операнд)


// тернарний оператор можна вкористовувати для умовних розгалужень замість if - else

// let result = умова ? значення1 : знначення2
// Спочатку обчислуюється умова: якщо вона правдива, тоді повертається значення1, інакше - значення2

// true ? 5 : 10 //  повернеться 5 бо воно правдиве
// true ? 5 : 10 // повернеться 10 бо 5 правдиве а ми просим знайти фолс, 10 теж правдиве, але тут ми просим повернути фолс значення в першій умові, оскільки воно не фолс, то повертається значення другої умови


//Задачка

//Якщо людина повнолітня, вивести "Ви повнолітній", інакше вивести "Ви не повнолітній"

//коротке рішення за допомогою тернарного оператора
// const age = 18;

// const resultString = age >= 18 ? "Ви повнолітній" : "Ви не повнолітній";
// console.log(resultString);


// класичне рішення через if-else

// const age = 18;
// let result = '';

// if (age >= 18) {
//         result = "Ви повнолітній";
// } else {
//         result = "Ви не повнолітній";
// }
// console.log(result);



//Задачка
//Користувач має три спроби ввести парроль
// Якщо пароль вірний, то вивести "Пароль вірний"
//Інакше "Пароль невірний"


// 1 класичний варіант рішення

// const TRY_LIMIT = 3;
// const PASSWORD_PATTERN = 'qwerty';

// let currentTry = 1;
// let isPasswordCorrect = false;

// do {
//         isPasswordCorrect = prompt('Input password: ') === PASSWORD_PATTERN;

// } while (++currentTry <= TRY_LIMIT && !isPasswordCorrect);

// if (isPasswordCorrect) {
//         console.log('Password is correct!');
// } else {
//         console.log('Pasword is incorrect!');
// }


// короткий варіант через тернарний оператор замість if-else + з шаблонним літералом

// const TRY_LIMIT = 3;
// const PASSWORD_PATTERN = 'qwerty';

// let currentTry = 1;
// let isPasswordCorrect = false;

// do {
//         isPasswordCorrect = prompt('Input password: ') === PASSWORD_PATTERN;

// } while (++currentTry <= TRY_LIMIT && !isPasswordCorrect);

// console.log(`Password is ${isPasswordCorrect ? 'correct' : 'incorrect'}`);

// ##############################################################################################################################################

// ###########################################################################################################################

                        // Functions

//  Функції - це блок коду, який виконує певні дії при її виклику
// повторне використання коду
// Одна функція - одна  відповідальність (одна задача)


// записується функція через спец слово    назва ф-ї   параметри  тіло ф-ї
//                                 function myFunction     ()     {}


//Оголошення фунцкії
// function fName(параметри) {  // параметрів може бути скільки завгодно
//      тіло ф-ї
        // return значення;  // оператор повернення - повертає результат виконання функції і припиняє виконання функції
                                // функція припиняє своє виконання на return, все що під ним нен виконається і називається "недосяжний код"
// }

//Виклик функції
//викликати функцію щоб вона працювала : назва функції() - дужки можна залишати пустими, або можна передавати ними аргументи
// myFunction(аргументи)   // аргументів може бути скільки завгодно (головне щоб аргументів було стільки ж скільки параметрів)



// function myFunction(userName) {   //userName це параметр фу-ї - це по суті локальна змінна в яку будуть передаватись аргументи при виклику цієї ф-ї
                                     //userName - це абстракція, на якій ми зав'язуємо логіку роботи функції (це формальний параметр)
//         // console.log(`Hello, ${userName}`);
//         const userGreeting = `Hello, ${userName}`;
//         return userGreeting;

// }
// Параметри які ми передаємо прри виклику функції це фактичні параметри
// myFunction('Irina');  // в дужках при виклику це аргументи
// myFunction('Vadim');

//функція виконається стільки разів скільки разів ми її викликаємо

// const a  = myFunction('Ivo');
// console.log(a);


// Написати функцію для обчислення суми двох чисел

// function sum(par1, par2) {
//         return par1 + par2; 
// }

// const result = sum(4, 5);  // після виконання функції result = 9
// console.log(result);  // 9 


//Написати функцію, яка приймає число, додає до нього 5 і виводить результат в консоль

// function myFunction2 (a) {
//         let result = a + 5;
//         return result;
// }
// const myFunction2Result = myFunction2(5);


//Написати функцію яка складає два числа і повертає результат розрахунку

// function addTwoNumbers (num1, num2) {
//         const result = num1 + num2;
//         return result;
// }

// const addTwoNumbersResult = addTwoNumbers(4, 4)

//Можна додавати, обробляти результати двох функцій разом
// console.log(myFunction2Result + addTwoNumbersResult);


// Написати функцію яка приймає 2 параметри і повертає a, b  і повертає a**b
// 2, 2 = 4
// 3, 4 = 81

// function myPow (a, b) {
//         return a**b;
// }

// const pow = myPow(3, 4); // 81
// console.log(pow);  // 81

//Написати функцію для обчислення суми цілих чисел від n1 до n2

// 1 і 5 = 1 + 2 + 3 + 4 + 5
// 

// function mySum (from, to) {
//         let result = 0;

//         for (let i = from; i <= to; i++) {
//                 result += i;
//         }
//         return result;
// }

// console.log(mySum(1, 5));
// console.log(mySum(5, 10));


//Написати функцію, якаприймає вік коритсувача, яка повертає true для повнолітнього користувача, false - для неповнолітнього

// function isAdult(userAge) {

//         //Рішення1
//         // if (userAge >= 18) {
//         //         return true;
//         // } else {
//         //         return false
//         // }


//         //Рішення 2
//         // return userAge >= 18 ? true : false;


//         //Рішення 3
//         return userAge >= 18;   // оскільки вираз userAge >= 18 є Булевим то він сам по собі повертає тру чи фолс, немає необхідності прописувати якщо тру то поверни тру, якщо фолс то поверни фолс. 
//                                 // Достатньо посто вказати щоб повернув результат виразу, і це все буде замість варіантів рішень 1 і 2

        
// }
// console.log(isAdult(5));




// --------------------------------------------------------------------

                // Способи задання функцій

// В JS функції є обєктами першого класу (First-class-citizen) - це означає, що вони можуть передаватись як параметр, повертатись із функції або присвоюватись змінній

// 1.function declaration - оголошення функції - оголошуємо функцію, потім її викликаємо по імені функції
//      у function declaration не важливо  чи ми спершу функцію написали чи спершу ї викликали, і так і так працює добре (перед виконанням скрипта, виконується перший пробіг по коду двіжком, потім вже виконання)
//      hoisting - оголошення функції піднімається (hoisted) до верхньої частини нашого коду (наче наша функція стає самим першим рядочком коду і викликати її ми можемо з будь якої точки коду)


//         function myFunction(userName) {  
//         console.log(`Hello, ${userName}`);
//         const userGreeting = `Hello, ${userName}`;
//         return userGreeting;
//          }
//          myFunction('Irina');  


// 2. function expression - функціональний вираз - кои ми в змінну кладемо функцію як значення, викликаємо функцію по назві змінної а не самої функції.
//      у function expression важливо щоб спершу була оголошена змінна значенням якої є функція, а вже потім виклик. Тому що ми не зможемо звернутись до змінної якщо вона не була оголошена раніще по коду
//      функціональним виразом воно називається, тому що ми створюємо змінну значенням якої є функція. При цьому в даному випадку сама функція не має власного імені
//      Функції які не мають назви називаються анонімними функціями
//      Функціональних виразах не відбувається hoisting, тому викликати її потрібно після її оголошення, так само як правила використання змінних спершу оголосити оптім використовувати.

// const calcSum = function (a, b) {
//         return a+b;
// };

// console.log(calcSum(2,5));


// Написати функцію  що приймає два параметри, і повертає число де a піднесений в степінь b
// const myPow = function (a, b) {
//         return a**b;
// }

// console.log(myPow(2,3));


// Написати функцію щоб привітати користувача

// const greet = function(userName) {
//         console.log(`Hi ${userName}`);
// }

// greet('Kevin');


// 3. Arrow function - стрілкові функції
        // В стрілкових функція hoisting не вібувається, викликати її потрібно після її оголошення/ініціалізації
 
// const iм'я_функції = (arg1, arg2) => {
//      тіло функції
// }


// Написати функцію щоб привітати користувача

// const greetArrow = (userName) => {
//         console.log(`Hi ${userName}`);
// }

// greetArrow('Masha')



// Анонімна функція - це функція у якої немає імені, ми не можемо до неї звернутись на пряму
// Щоб звертатись до Анонімної фукції ми звертаємось до змінної в якій зберігається ця функція


// Коли можна залишити пустими дужки з параметрами функції??
// Круглі дужки можна залишити пустими тоді. коли нам не потрібні параметри!
// Параметри нам не потрібні тоді, коли робота фунції не залежить від якогось зовнішнього значення


//Задача написати функцію, яка виводить системну дату та час (поточні)   ^

// const getDateWithTime = function() {
//         const dateWithTime = new Date();
//         return dateWithTime;
// }
//Викличем її тоді коли вона буде нам потрібна



// Буває так нам не всі параметри потрібно передавати, 
// тобто у функції три параметри, а ми передаємо лише два

// Значення за умовчуванням

//Наприклад prompt має не лише один параметр як ми раніше писали, а має ще другий параметр default - значення яке ми там зазначимо буде по замовчуванню вписане в строку введення
// параметр default не є обовязковим, якщо ми його не вказуємо, то поле для вводу просто буде пустим, тобто там буде просто пустий стрінг ''
// const value = prompt('Input number', 10);
// console.log(value);


//Знайти суму двох чисел якщо друге число не передане то вважати його 1

// ми можемо вказати 2 параметри, перший обовязковий, а другий по дефолту 1 а якщо ми передамо обидва аргумента то буде дорівнювати тому що передали як аргумент
// якщо не вказати дефолтне значення в цьому випадку, то  буде undefind для другого парамера, якщо ми передамо лише 1 аргумент
// дефолтне значення можна вказувати лише для останньго параметра.

// function sum2(a, b=1) {
//         return a + b;
// }

// console.log(sum2(2, 3));
// console.log(sum2(2));


//Написати функцію для обчислення суми цілих чисел від n1 до n2

// 1 і 5 = 1 + 2 + 3 + 4 + 5
// 

// function mySum (from, to) {
//         let result = 0;

//         for (let i = from; i <= to; i++) {
//                 result += i;
//         }
//         return result;
// }

// console.log(mySum(1, 5));
// console.log(mySum(5, 10));

// Переписати функцію зверху так, щоб при передачі тільки одного аргумента то це має бути to

// function mySum (to, from = 1) {
//         let result = 0;

//         for (let i = from; i <= to; i++) {
//                 result += i;
//         }
//         return result;
// }

// console.log(mySum(10));


// ######################################################################################################################

                // JS doc - як писати документацію до свого коду JS

// https://jsdoc.app/
// Документацію пишемо в таких межах /** */
// Документація потрібна для розуміння написаного коду в майбутньому
// Розписується все так як в прикладах нижче
// Детальна інструкція з написання документації на сайті https://jsdoc.app/


// /**
//  * Function calculate the sum of two numbers
//  * @param {number} to  - First summand
//  * @param {number} [from = 1]  - Second summand
//  * @returns {number} - Sum of arguments
//  */
// function mySum (to, from = 1) {
//         let result = 0;

//         for (let i = from; i <= to; i++) {
//                 result += i;
//         }
//         return result;
// }

// console.log(mySum(10));



// Написати функцію яка приймає 2 параметри і повертає a**b
// 2, 2 = 4
// 3, 4 = 81

// /**
//  * Function powers a to b parameter
//  * @param {number} a  - First arg
//  * @param {number} b  - Second arg
//  * @returns {number}  Number a powered to number b
//  */

// function myPow (a, b) {
//         return a**b;
// }

// const pow = myPow(3, 4); // 81
// console.log(pow);  // 81



// ###########################################################################################################


                // Objects - Об'єкти


// функція alert() не підтримує виведення обєктів

// Способи задання обєктів
// const obj1 = {};  //синтаксичний цукор 
// const obj2 = Object();
// const obj3 = new Object();


// console.log(obj1);
// alert(obj1)  - не може вивести обєкт

// Ініціалізація обєктів:


//Властивості мають тип даних -  string та symbol()
// const user = {
//            // key: value
//         firstName: 'Test',
//         lastName: 'Testobych',
//         age: 25,
//         password: 'qwerty'
// };
// console.log(user);

// Отримати доступ до властивостей обєкта звертаємось до обєкта і через . до властивості

// const userName = user.firstName; // отримуємо доступ до властивості firstName обєкту user
// console.log(userName); // консоль виведе Test


// Щоб змінити значення якоїсь властивості обєкта звертаємось до обєкта і через . до властивості + присвоюємо їй нове значаення

// user.age = 26;
// console.log(user); // Ми змінили вік юзера в обєкті

// Щоб додати нову властивість обєкту звертаємось до обєкта і через . вказуємо назву нової властивості яку додаємо + присвоюємо їй значаення

// user.email = 'test@mail.com';
// console.log(user); // ми додали в обєкт ще одну властивість і значення

// Щоб видалити одну з властивостей пишемо слово delete через пробіл звертаємось до обєкта і через . до властивості

// delete user.password;
// console.log(user);  // ми видалили властивість password разом зі значенням



//Задача
//Створити об'єкт машини (марка, модель, рік випуску, номер, колір)
//Переглянути обєкт
//Змінити колір
//Видалити властивість рік випуску
//додати властивість ПІБ власника
//Переглянути об'єкт

// const car = {
//         carBrand : 'Mazda',
//         carModel : 'CX 30 Electro',
//         year: 2020,
//         number: 'AO1234AI',
//         color: 'white'
// }

// console.log(car);

// car.color = 'red';
// delete car.year;
// car.owner = 'Vasya Petrov';
// console.log(car);



// -------------------------------------------------------------------------------------------------------------------

// Типи значення (примітиви) і посилальні типи (обєкти)

// Порівнюємо однакові примітиви
// const numberValue1 = 5;
// const numberValue2 = 5;
// console.log(numberValue1 === numberValue2);  // true  - тому що містить значення


//Порівнюємо однакові обєкти
// const objValue1 = {};
// const objValue2 = {};
// console.log(objValue1 === objValue2);  // false  - тому що містить посилання і вони у всіх різні


//  Копіювання обєктів

// НЕ правильне копіювання обєктів : так копіювати не можна, якщо ми в копію внесем зміни то ці зміни внесуться і в оригінал

// const user1 = user;

// user1.firstName = 'Anna';
// console.log(user1);
// console.log(user);
// console.log(user === user1);  // true  - тому що через це копіювання ми просто скопіювали посилання а вони однакові в обох обєктах, По тій же причині ми внесли зміни в останній обєкт а змііни застосувались і до копії і до оригіналу


// Правильне копіювання об'єтів: використовуючи assign{новий обєкт, той який копіюєм}

// const user2 = Object.assign({}, user);
// console.log(user2);
// console.log(user === user2);  // false - вони різні, змінюючи один ми не змінимо оригінал

// Правильне копіювання об'єтів: використовуючи {... той який копіюєм}

// const user3 = {...user}
// console.log(user3);
// console.log(user === user3);  // false  - вони різні, змінюючи один ми не змінимо оригінал



// Задача
// Зробити копії для об'єкту car

// const car2 = Object.assign({}, car);
// car2.color = 'black';
// console.log(car2);
// console.log(car === car2);

// const car3 = {...car2};
// car3.color = 'silver';
// console.log(car3);
// console.log(car2 === car3 === car);


// #######################################################################################################################################


                // Функції-конструктори (Functions-constructors)


// Звичайний синтаксис {...} дозволяє створити тільки один об’єкт. 
// Проте часто нам потрібно створити багато однотипних об’єктів, таких як, наприклад, користувачі чи елементи меню тощо.
// Це можна зробити за допомогою функції-конструктора та оператора "new".

// технічно функціх-конструктори - це звичайні фукції. Однак є дві загальні домовленості:
// 1. ім'я функції конструктора повинно починатися з великої літери.
// 2. функції-конструкторои повинні виконуватися лише з оператором new.

// Основною метою конструкторів є зручне перевикористання коду зі створення об’єктів.


// Коли функція виконується з new, відбуваються наступні кроки:

// Створюється новий порожній об’єкт, якому присвоюється this.
// Виконується тіло функції. Зазвичай воно модифікує this, додає до нього нові властивості.
// Повертається значення this.


//ТАК НЕ пишем функції-конструктори, це приклад як працює функція-конструктор під капотом
// function User (firstName, lastName, age, password) {
//         const this = {};
//         this.name = firstName;
//         this.surname = lastName;
//         this.age = age;
//         this.password = password;

//         return this;
// }
//Передаємо параметри в  функцію-конструктор для створення обєкта
// const user1 = User ('Anna', 'Tovt', 6, 'qwerty');

//Назву функцію пишем з UpperCaleCase і викликається з оператором new
// function User (firstName, lastName, age, password) {
//         //змінна this = {} - сама створюється і працює під капотом завдяки оператору new
//         this.name = firstName;
//         this.surname = lastName;
//         this.age = age;
//         this.password = password;
//         //можна додавати у функцію конструктор і інші методи(функції), наприклад щоб збільшити вік юзера коли в нього день народження (для цього звісно потрібно знати дату народженння, але для прикладу зробим функцію не знаючи дати)
//         //Задачка, перенести метод makeOlder в прототип
//         // this.makeOlder = function () {
//         //         this.age++;
//         // }
//         // return сам відпрацьовує під капотом завдяки оператору new
// }
// //Передаючи параметри в  функцію-конструктор для створення обєкта не забуваємо про оператор new
// const userA = new User ('Anna', 'Tovt', 6, 'qwerty');
// console.dir(userA);

// const userB = new User ('Yurii', 'Tovt', 37, 'Qwerty');
// console.dir(userB);


//тут наче викликаємо функцію для збільшення віку у функції-конструкторі 
// userA.makeOlder();
// console.log(userA);  // отримуєм на 1 рік більше ніж було
// console.log(userB); // а тут вік лишився той самий


// Тепер для ми створили конструктор, який для кожного користувача створює екземпляр обєкту з персоналізованими даними.
// Але, оскільки наш конструктор містить в собі метод (функцію) по збільшенню віку юзера, то кожен обєкт юзера теж його містить, а це дублювання коду
// Як зробити метод по збільшенню віку, щоб він відпрацьовував на кожного обєкта юзера, при цьому не зберігався в кожному обєкті юзера, щоб не було дублювання
// Треба наш метод по збільшенню віку застосувати не до this (бо він є нашим майбутнім екземпляром обєкту юзера, а присвоїти його самій функції конструктору User)
// Для цього використовується поняття Прототипу обєкта
// Прототип обєкта - це механізм, за допомогою якого обєкти наслідуються властивості одне одного

// Прототип це метод який дозволяє перевикористувати якісь спільні методи із загального батьківського обєкту 

//Задати обєкт
// const userProto = {};    // можна ще задати так: const user = new User(); 
// // Прописати в ньому метод
// userProto.changePassword = function(newPassword) {
//         this.password = newPassword;
// };
// // userProto.makeOlder = function () {
// //         this.age++;
// // };
// // Призначити створений обєктв  властивість prototype у функції-конструктора
// User.prototype = userProto;

// //Можна ще метод прописувати прямо в User.prototype  ось так:
// // User.prototype.makeOlder= function () { 
// //         this.age++; 
// // };

// console.log(userA.makeOlder === userB.makeOlder); // false - тому що зберігається в властивостях кожного юзера, і оскільки обєкт є посилальним типом то вважається що метод makeOlder різний в кожного користувача
// console.log(userA.changePassword === userB.changePassword);  // true - тому що привязаний через прототип, так само досупний для кожного обєкта юзера, але не дублюється як властивість в кожному обєкті і вважається однаковою бо створена з одного місця


// Згадуємо що всі типи даних мають свої методи
// коли наприклад метод Number викликається в якості конструктора з ключовим словом new він створює обєкт Number, який НЕ являється примітивом це не звичний нам number як тип даних.
// так от обєкт Number створений через new має набір методів напр (Number.isFinite(), Number.isNaN(), Number.parseFloat().... а також властивості Number.MAX_VALUE, Number.EPSILON, Number.NEGATIVE_INFINITY...)
// але якщо наш Number є екземпляром Number з оператором new (тобто був створений на основі конструктора) то в нього будуть свої метожи з ключовим словом prototype (напр Number.prototype.toFixed(), Number.prototype.toString(), Number.prototype.valueOf()...)
// отже для обєкту Number є свої методи і властивості, а для екземпляру обєкту є свої з словом prototype, і працюватимуть вони лише в своїх межах. 

//статичні методи і властивості 
// User.AVG_AGE = 85; // ми призначили середній вік, тобто взяли і створили властивість і значення, але він не буде наслідуватись екземплярами, тому що ми його присвоїли самій функції

// методи інстанса / екземпляра
// User.prototype.AVG_AGE = 65; // ми призначили середній вік, взіли і створили властивість для екземпляру і присвоїли знаечння, цей метод буде наслідуватись екземплярами, тому що ми його присвоїли в прототип функції

// В JS всі методи наслідуються в прототипах (Наслідування це один з принципів ООП)

// -------------------------------------------------------------------------------------------------------------------------

                // Перевірка типу обєкта 

// instanceof в JavaScript — це оператор, який використовується для перевірки, чи є об'єкт екземпляром певного класу або конструктора.

// Як це працює в JavaScript:
// Ви створюєте класи або функції-конструктори для створення об'єктів.
// Коли ви створюєте об'єкт, він стає екземпляром цього класу або конструктора.
// instanceof перевіряє, чи належить об'єкт до певного типу.

// Навіщо це потрібно:
// Перевірка типу: Іноді потрібно переконатися, що об'єкт належить до певного типу, перш ніж виконувати певні дії.
// Успадкування: instanceof також може перевірити, чи успадковує об'єкт від певного класу.
// Обробка помилок: Ви можете використовувати instanceof для перевірки, чи є помилка екземпляром певного типу помилки.

// console.log(userA instanceof User);  // перевіряємо чи обєкт userA насправді є ексземпляром функції-конструктора User (тобто чи був userA створений за допомогою User)

// if (userA instanceof User) {
//         console.log('userA is User');
// } else {
//         console.log('userA is not User');
// }
// }



// ###########################################################################################################################################################

                // Конструкція Switch...case


// Задача: Написати програму, яка перевіряє число на те, чи ділиться воно на 2, 3 або 5


// const number = Number(prompt('Enter a number: '));

// if(number % 5 === 0) {
//         console.log(number + ' is divisible by 5');
// }
// if(number % 3 === 0) {
//         console.log(number + ' is divisible by 3');
// }
// if(number % 2 === 0) {
//         console.log(number + ' is divisible by 2');
// }

// Результат виведення буде кожен з if який ділиться націло, тобто число 10 буде ділитись на 5 і на 2 і в консоль виведуться два записи
// А якщо нам потрібно вивести лише один дільник для 10 ?
// Ми можемо почерзі перевірити через else if співпадіння


// if(number % 5 === 0) {
//         console.log(number + ' is divisible by 5');
// } else if(number % 3 === 0) {
//         console.log(number + ' is divisible by 3');
// } else if(number % 2 === 0) {
//         console.log(number + ' is divisible by 2');
// } else {
//         console.log(number + "isn't divisible by 5, 3 or 2");
// };

// Через else if ми отримаємо лише перший правдивий результат, тобто в нашому прикладі в консоль виведеться що 10націло ділиться на 5

// Тепер уявімо що у нас буде 100 рядків коду з умовами, його убде важко читати
// для того щоб не роздувати else if до нечитабельнтх розмірів існує конструкція switch
// switch - інструкція, яка порівнює вирази з випаадками, які перечислені всередині неї, а потім виконує відповідні інструкції 
// switch - це спосіб реалізації вибору з декількох можливих варіантів в залежності від значення виразу

// Основна відмінність між if та switch полягає в способі перевірки умов.
//  Конструкція if перевіряє одну або декілька умов за допомогою логічних виразів
// Інструкція switch перевіряє одну змінну на різні можливі значення
// Конструкція switch використовується у випадках, коли перевіряється одна змінна на різні значення

// Синтаксис

/*
switch (вираз - якась змінна) {
        case значення _виразу: робимо щось одне;
        case значення2_виразу: робимо щось інше;
        case значення3_виразу: робимо ще щось іншне;
        default: робимо щоь якщо інші значення не підійшли
}

*/


// Задача: нам приходить номер місяця, за номером місяця потрібно визначити пору року

// const monthNumber = 3;

// switch(monthNumber) {
//         case 1: {
//                 console.log('winter');
//                 break;    // ключове слово break використувується для припинення виконання блоку switch і виходу із нього як тільки виконується case
//         }
//         case 2: {
//                 console.log('winter');
//                 break;
//         }
//         case 3: {
//                 console.log('spring');
//                 break;
//         }
//         case 4: {
//                 console.log('spring');
//                 break;
//         }
//         case 5: {
//                 console.log('spring');
//                 break;
//         }
//         case 6: {
//                 console.log('summer');
//                 break;
//         }
//         case 7: {
//                 console.log('summer');
//                 break;
//         }
//         case 8: {
//                 console.log('summer');
//                 break;
//         }
//         case 9: {
//                 console.log('autumn');
//                 break;
//         }
//         case 10: {
//                 console.log('autumn');
//                 break;
//         }
//         case 11: {
//                 console.log('autumn');
//                 break;
//         }
//         case 12: {
//                 console.log('winter');
//                 break;
//         }
//         default: {                    // дефолтне значення потрібно для того щоб обробити значення змінної якщо воно не співпало з жодним кейсом (тобто значення не передбачені кейсами)
//                 console.log('Enter a number from 1 to 12');
//                 break;  // в defolt можрна нен ставити break тому що це останній рядок контструкції, і він логічно сам завершить виконання і вийде з конструкції
//         }
// }

// ключове слово break використувується для припинення виконання блоку switch і виходу із нього як тільки виконується case
//інакше навіть знайшовши співпадіння на початку switch воно добіжить з того кейса де відбулось співпадіння аж до кінця контструкції і виведе вс консоль всі кейси в т.ч. дефолт від кейсу співпадіння до дефолту
// щоб цього не відбувалось потрібно в кожному кейсі проставити ключове слово break

// Якщо повернутись до попередньої задачі з діленням на 5,3,2  і уявімо що ми хочемо отримати всі можливі дільники і вивести по ним всім інфо в консоль, тоді можна не ставити break, break поставим лише перед дефолтом в передостанньому кейсі щоб дефолт не враховувався


// В конструкції swicth ми можему групувати значення case.
// групування дає змогу виконувати код для кількох варіантів значення
// у задачі з місяцями є ситуації коли для декількох місяців потрібно вивести одну й ту ж пору року


// const monthNumber = 12;

// switch(monthNumber) {
//         case 1:
//         case 2: 
//         case 12: {
//                 console.log('winter');
//                 break;    // ключове слово break використувується для припинення виконання блоку switch і виходу із нього як тільки виконується case
//         }
//         case 3:
//         case 4:
//         case 5: {
//                 console.log('spring');
//                 break;
//         }
//         case 6:
//         case 7:
//         case 8: {
//                 console.log('summer');
//                 break;
//         }
//         case 9:
//         case 10:
//         case 11: {
//                 console.log('autumn');
//                 break;
//         }
//         default: {                    // дефолтне значення потрібно для того щоб обробити значення змінної якщо воно не співпало з жодним кейсом (тобто значення не передбачені кейсами)
//                 console.log('Enter a number from 1 to 12');
//                 break;  // в defolt можрна нен ставити break тому що це останній рядок контструкції, і він логічно сам завершить виконання і вийде з конструкції
//         }
// }




//Задача 1
/* Prompt
Виведіть користувачу пропозицію меню
1 - Сік
2 - Вода
3 - Кава
4 - Чай
5 - Лимонад

В залежності який номер ввів користувач вивести в консоль напій "Сік", чи "Вода"...
Зробити через switch-case
*/


// const menu = Number(prompt('Choose a dring entering the necessary number : \n 1. Juice \n 2. Water \n 3. Coffee \n 4. Tea \n 5. Lemonade'));

// switch(menu) {
//         case 1: {
//                 console.log('Your juice is almost ready!');
//                 break;
//         }
//         case 2: {
//                 console.log('Your water is almost ready!');
//                 break
//         }
//         case 3: {
//                 console.log('Your coffee is almost ready!');
//                 break;
//         }
//         case 4: {
//                 console.log('Your tea is almost ready!');
//                 break;
//         }
//         case 5: {
//                 console.log('Your lemonade is almost ready!');
//                 break;
//         }
//         default: {
//                 console.log('Ooops! It seems like you entered incorrect value. Please try again.');
//                 break;
//         }
// }



// Задача 2
/*
Зробити калькулятор

Користувач послідовно один за одним вводить :
- Перше число
- Друге число
- Один з варіантів: +, -, * , /

Для кожної математичної дії можна зробити окрему функцію
Весь калькулятор це теж окрема функція роль якої спитати у користувача два числа і дію і повернути йому рпезультат обчислення через alert

P.S. Повна творча свбода
Якщо ви бачите рішення цієї задачі якось інакше ви можете реалізувати своє бачення калькулятора

*/



// const firstNum = Number(prompt('Enter the first number:')),
//       secondNum = Number(prompt('Enter the second number:')),
//       operator = prompt('Enter the necessary operator (+, -, *, /):');

// const calc = function() {

//         function addition(firstNum, secondNum) {
//                 let sum = firstNum + secondNum;
//                 return alert(`The value of expression ${firstNum} + ${secondNum} equals ${sum}!`);
//         };
//         function subtraction(firstNum, secondNum) {
//                 let sum = firstNum - secondNum;
//                 return alert(`The value of expression ${firstNum} - ${secondNum} equals ${sum}!`);
//         };
//         function multiplication(firstNum, secondNum) {
//                 let sum = firstNum * secondNum;
//                 return alert(`The value of expression ${firstNum} * ${secondNum} equals ${sum}!`);
//         };
//         function division (firstNum, secondNum) {
//                 let sum = firstNum / secondNum;
//                 return alert(`The value of expression ${firstNum} / ${secondNum} equals ${sum}!`);
//         };

//         switch(operator) {
//                 case '+': {
//                         addition(firstNum, secondNum);
//                         break;
//                 }
//                 case '-': {
//                         subtraction(firstNum, secondNum);
//                         break;
//                 }
//                 case '*': {
//                         multiplication(firstNum, secondNum);
//                         break;
//                 }
//                 case '/': {
//                         division(firstNum, secondNum);
//                         break;
//                 }
//                 default: {
//                         alert(`You entered incorrect operator!`);
//                 }
//         }
// }

// calc();





// ####################################################################################################################################


                // Масиви (Arrays)

// Array - використовується для зберігання впорядкованих колекцій


//Способи задання масивів:

// const arr1 = new Array();
// const arr2 = Array();
// const arr3 = [];  // синтаксичний цукор, коли ми його використ то JS під капотом викликає перший спосіб new Array()
// const arr4 = new Array.prototype.constructor(1, 2)


// Масиви іменують в множині (щоб було зрозуміло що там колекція даних)
// Дані в масиві розділяються комами

// const numbers = [1, 2, 3, 4];  // перелік примітивів напр
// const users = [
//         {id: 1, name: 'Test'},  // перелік об'єктів в середні масива (тобто елементами масиву можуть бути будь які типи даних)
//         {id: 2, name: 'Ivo'}
// ];

// console.log(users);  // виводимо весь масив в консоль

//Масив має вбудовану властивість length яка дозволяє перевірити кількість елементів в масиві
// console.log(users.length);  // вивести кількість елементів масиву, тобто перевірити його довжину


// Елементи ммасиву мають свій порядковий номер, що називається індексом.
// Індексація в масиві починається з 0. Тобто якщо нам потрібно отримати перший елемент то звертаємось од індексу 0, якщо другий елемент, то звертаємось до індексу 1
// Останній елемент масиву можна отримати за допомогою arr.length - 1

// щоб добратись до конкретного елемента масиву використовуємо [] напр users[0] - отримуємо перший елемент масиву
// якщо ми звернемось до індексу елемента якого не існує то отримаємо у відповідь undefined
// [] - це синтаксис запису обчислювальних властивостей

// console.log(users[0]);  // вивести елемент масиву (за індексом)


// Оскільки в JS динамічна типізація, то впринципі відсутні обмеження щодо того які дані можуть зберігатись в масивах
// тому цілком допускається створювати масиви змішаного типу

// const fantastic = [1, 'qwerty', {name: 'User1'}]  // але це не дуже добра практика, всетаки краще обмежуватись одним типом в масиві для подальшої маніпуляції з елементами



// Задачка:
// Задати масив в якому перераховано три перші місяці року

// const months = ['January', 'Fabruary', 'March'];



// --------------------------------------------------------------------------------------------------------------------------------------------


                // Перебір елементів масивів циклами


//  const months = ['January', 'Fabruary', 'March'];


// цикл for

        // i=0 тому що перший елемент масиву знаходиться під індексом 0
        // i <= months.length - 1 тому що останній елемент масиву це довжина масиву мінус 1. (тобто якщо ми використовуєм <= то мусимо від довжини відняти 1, бо в нас є три елемента від 0 до 2, тобто останній елемент має індекс 2, але властивість length = 3, а елемента з індексом три у нас в масиві неіснує, буде undefined)
        // i < months.length можем використати замість попереднього рядка, тому що знаком < без = ми вже не включаємо останній індекс який виникає в різниці з length  

// for (let i = 0; i <= months.length - 1; i++) {
//         console.log(months[i]);  // виведем в консоль кожен елемент масиву починаючи з 0 індексу і закцінчуючи 3-1 (тобто індексом 2)
// }





// ---------------------------------------------

// Щоб погратись на сторінці можна використовуввати функцію document.write();
// За її допомогою можна на сторінку виводити розмітку html
// функція document.write(); НЕ використовується в  робочих кодах, це лише щоь погратись

// document.write('<h1>Users</h1>');  // приклад виведення заголовку першого типу на сторінку


// Тепер спробуємо вивсети на сторінку список місяців. (Масив з примітивами)
// Для цього спершу відкриваєм тег ul, далі прописуємо цикл де створяться li, після циклу закриваємо тег ul

// const months = ['January', 'Fabruary', 'March'];

// document.write('<h1>Months list</h1>');  // виводим заголовок

// document.write('<ul>');  // відкиваєм тег ul щоб створити ненумерований список

// for (let i = 0; i < months.length; i++) {
//         document.write(`<li>${months[i]}</li>`)  // перебираємо масив з місяцями виводячи кожен елемент масиву на веб сторінку
// }

// document.write('</ul>'); // закриваєм тег ul




// Тепер спробуємо вивести користувачів (Масив з обєктами!)

// const users = [
//         {id: 1, name: 'Test'},
//         {id: 2, name: 'Ivo'}
// ];

// document.write('<h1>Months list</h1>');  // виводим заголовок

// document.write('<ul>');  // відкиваєм тег ul щоб створити ненумерований список

// //document.write так само як і alert не вміє виводити обєкти, якщо ми таке захочем вивести то отримаєм [object Object] замість значень
// //Щоб отримати значення обєкту в масиві потрібно звернутись до масива далі через [] до елемента масива за індексом, а далі через крапочку пишем імя властивості обєкту users[i].name
// for (let i = 0; i < users.length; i++) {
//         document.write(`<li>${users[i].id} ${users[i].name}</li>`)  // перебираємо масив з юзерами виводячи кожен елемент масиву на веб сторінку
// }

// document.write('</ul>');



// Задачка:
// Задати масив з довільниз чисел і вивести тільки додатні з них


// const arrNumbers = [1, 0, -5, 0.28, -93, 55, -0.68];

// for (let i = 0; i < arrNumbers.length; i++) {
//         if (arrNumbers[i] >= 0) {
//                 console.log(arrNumbers[i]);
//         }
// };



// Задачка
// Реалізувати функцію для підрахунку суми елементів масиву

// const numbers1 = [1, 5, 10, 15, Math.random()];
// console.log(numbers1);

// const sumOfNumbers1 = calcSum(numbers1);
// console.log(sumOfNumbers1);

// function calcSum(array) {
//         let sum = 0;     // змінна для накопичення
//         for (let i = 0; i < array.length; i++) {
//                 sum += array[i];
//         }
//         return sum;
// }


// Перебір елементів спеціалізованими ключами
// Для перебору обєктів за властивостями ми використовували цикл for ... in

// for (let index in months) {
//         console.log(index, months[index]);   // ми впринципі отримаємо таким чином індекс і його значення, але for...in не використовується для масивів.
// }

// 0 January
// 1 Fabruary
// 2 March

// Замість for...in для обєктів , використовується for...of для масивів
// for...of - це спеціальний цикл для перебору самих елементів (не індексів) масивів та будь яких елементів якці зручно перебирати
// а for...in - це цикл для перебору індексів (але не самих елеменів), тому його використовують в обєктах для перебору по властивостям
// for...in - index
// for...of - item

// for (let item of months) {
//         console.log(item);
// }

// January
// Fabruary
// March



// ################################################################################################################################################################

                // Копіювання масивів

// З копіюванням масивів ситуація така сама як з обєктами. Масив це той самий обєкт який містить посилання на комірки для збереження даних.
// якщо ми просто зробим копію через присвоювання і внесем зміни, то зміниться і в копії і в основному масиві

// const numbers2 = numbers1;   // так НЕ ПИШЕМО! Копіюються тільки посилання

// const numbers3 = [1, 2, 3, 4];


// // 1. через вбудований статичний метод Array.from()  - створює масив з ітерованого обєкта

// const numbers2Copy1 = Array.from(numbers2);   // створюємо копію з numbers2
// console.log(numbers2===numbers2Copy1); // false  - якщо ми в цій копії щось змінимо,то масив numbers2(оригінал) залишиться без змін

// // 2. через розширення ...назва масиву з якого робим копію

// const numbers2Copy2 = [...numbers2];    // тут ми наче розгортаємо всі нутроші масиву numbers2 в його копію
// console.log(numbers2===numbers2Copy2);  // false


// const arr = [1, 2, 3, 4, 5];
// arr.splice(0, 2);  // (3) [3, 4, 5]  - отримаємо масив видаленими першими двома елементами
// arr.push('6'); // (6) [1, 2, 3, 4, 5, '6'] - отримаємо масив з числами, лише останній елемент буде стрінг
// arr.length = 0;    //  отримаємо пустий масив
// arr = [...arr, '4'];  // помилка бо хочемо змінити масив який є константою
// console.log(arr);


// // 3. через метод .slice() - у нього кілька параметрів: перший це початок - індекс з якого починаємо, другий це кінець - індекс на якому закінчуємо. Можна вказати лише перший параметр, тоді зкопіює з того що ми вказали о кінця, можна не вказувати жоден параметр, тоді зкопіюємо увесь масив

// const numbers2Copy = numbers2.slice();
// console.log(numbers2Copy);
// console.log(numbers2Copy === numbers2);  // false

// ####################################################################################################################################################


                // Методи масивів

// .push() - додає новий елемент в кінець масиву і повертає нову кількість елементів в масиві (сам змінює length)
// .pop() - видаляє останній елемент масива і повертає значення видаленого елемента
// .unshift() - додає новий елемент на початок масиву і повертає нову кількість елементів в масиві
// .shift() - видаляє перший елемент масива і повертає значення видаленого елементу
// .slice() - копіювання частини елементів масиву (у нього кілька параметрів: перший це початок - індекс з якого починаємо, другий це кінець - індекс на якому закінчуємо. Можна вказати лише перший параметр, тоді зкопіює з того що ми вказали о кінця, можна не вказувати жоден параметр, тоді зкопіюємо увесь масив)
// .splice()  - видалення частини елементів з масиву (змінює масив видаляючи або додаючи нові елементи) (він дуже параметризований, його можна по різному використовувати. Перший параметр обовязковий це індекс з якого починаємо зміни, відємний індекс використовується щоб почати з кінця масиву)


// const numbers4 = [1, 2, 3, 4, 5];
// numbers4[5] = 6;  // додаємо ще один елемент під індексом 5 (тобто задаючи конкретне місце положення елементу в масиві )
// numbers4[numbers4.length - 1] = 7; // додаємо ще один елемент в кінець масиву 

// Вище описані способи не є кращим рішенням, але цілком робочі. Краще використовувати методи:

// numbers4.push(8);  // метод push автоматично знаходить де кінець масиву і додає в кінець новий елемент і повертає нову кількість елементів в масиві
// console.log(numbers4);

//Ввести кількість елементів масивву і динамічно заповнити масив

// const elementCount = +prompt('Enter count: ');
// const elements = [];

// for (let i = 0; i < elementCount; i++) {
//         const elem = +prompt('Input number');
//         elements.push(elem);
// }
// console.log(elements);   // (3) [5, 6, 7]


// const removedElement = numbers4.pop();  // видаляємо останній елемент з масива і повертаємо значення видаленого елемента
// console.log(removedElement);  // 8 
// console.log(numbers4);  //(6) [1, 2, 3, 4, 5, 7]  - попередній масив з видаленм останнім елементом

// const colors = ['red', 'blue', 'green', 'pink'];
// colors.pop();
// colors.push('orange');
// console.log(colors);  // ['red', 'blue', 'green', 'orange']


// numbers4.shift();  // видаляємо перший елемент з масива і повертаємо значення видаленого елемента
// console.log(numbers4); //(5) [2, 3, 4, 5, 7] - попередній масив з видаленим першим елементом

// numbers4.unshift(10);  // додаємо новий елемент на початок масиву
// console.log(numbers4);  //(6) [10, 2, 3, 4, 5, 7]

// Методи shift та unshift що додають чи видаляють елемени з початку масиву перебудовують увесь масив змінюючи індекси поточних елементів
// Це доволі неефективна затратна операція для JS, тому по можливості бажано їх не використовувати якщо можна зробити якось інакше


// const numbers4Copy = numbers4.slice();  // робим копію всього масиву
// console.log(numbers4Copy);
// console.log(numbers4Copy === numbers4); // false  - масиви різні, тобто якщо я внесу зміни в копію, то оригінал не зміниться

// const numbers4Part1 = numbers4.slice(2);  // копіюємо весь масив починаючи з індекса 2 закінчуючи останнім елементом в масиві
// console.log(numbers4Part1);  //(3) [3, 4, 5]  тут перед slice numbers4 = [1, 2, 3, 4, 5];

// const numbersPart2 = numbers4.slice(1, 4);  // копіюємо весь масив починаючи з індекса 1 закінчуючи індексом 4 (не включно)
// console.log(numbersPart2);  // (2) [2, 3, 4]   тут перед slice numbers4 = [1, 2, 3, 4, 5];

// numbers4.splice(2, 1);  // (параметр 1 - з якого індексу починаєм видаляти, параметр 2 - кількість елементів що будем видаляти), тобто я хочу видалити 1 елемент починаючи з індекса 2
// console.log(numbers4); // (4) [1, 2, 4, 5]  - ми видалили 3 з масиву, і автоматично змінрилась кількість елементів в масиві, тепер length = 4, крім того він повертає той елемент який видаляє, треба бути обережним


//Задачка
//видалити 1 перший елемент і скопіювати останніх два елементи

// numbers4.splice(0, 1);
// const numbers4Copy = numbers4.slice(-2)
// console.log(numbers4);
// console.log(numbers4Copy);


// --------------------------------------------------------------------------------------------------------------------------------

                // Конкатенація масивів (Arrays concatination)

// Щоб корректно зконкатинувати масиви є безліч способів

// const arr5 = [5, 6, 7];
// const arr6 = [1, 2, 3];

// // 1. через метод concat - де перший масив це той до якого приклеюємо, другий то який приклеюємо, тре бути уважними якщо порядок принциповий

// const arr7 = arr5.concat(arr6);
// console.log(arr7);  //(6) [5, 6, 7, 1, 2, 3]

// // 2. через спосіб копіювання масиву через розширення ... , тобто розгорнути потрібні масиви в новому масиві

// const arr8 = [...arr5, ...arr6];
// console.log(arr8); //(6) [5, 6, 7, 1, 2, 3]










// ###########################################################################################################################################

                // Методи перебору масивів forEach, map, filter, findIndex (Methods of arrays searching)
                // Поняття колбеку (Callback concept)


// Поняття callback

// Callback - це як "зроби це, коли закінчиш". Ми даємо одній функції іншу функцію, щоб вона зробила її, коли закінчить свою роботу.

// Callback - це функція, яка передається в іншу функцію і викликається в середині неї

// Функція зворотного виклику (ФЗВ, Callback) – це функція, що передається до іншої функції як аргумент, який потім викликається всередині зовнішньої функції, щоб завершити якогось роду процедуру або дію.



// function funcWithCallback(cb, value) {  // де перший парам- це колбек-фунцкія, другий це параметр це аргумент
//         cb(value);
// }

// funcWithCallback(alert, 'Hello');
// funcWithCallback(console.log, 'Hello from console');



// function someAction(x, y, someCallback) {
//         return someCallback(x, y);
// }

// function calcProduct(x, y) {
// return x * y;
// }

// function calcSum(x, y) {
// return x + y;
// }
// // alerts 75, the product of 5 and 15
// alert(someAction(5, 15, calcProduct));
// // alerts 20, the sum of 5 and 15
// alert(someAction(5, 15, calcSum));

// Спочатку функція someAction визначається з аргументом-колбеком someCallback. Потім, як можливий колбек для someAction, визначається функція calcProduct. 
// Інші функції також можуть використовуватися для  someCallback, наприклад calcSum. У цьому прикладі someAction() викликається двічі: спочатку використовуючи 
// як колбеку calcProduct, і ще раз — як колбек маючи calcSum. Функції повертають відповідно добуток та суму, що потім відображаються на екрані за допомогою alert.



// ------------------------------------------------------------------------------------------------------------------------------



                // Методи перебору масивів forEach, map, filter, findIndex (Methods of arrays searching)

// 1. forEach -  виконує вказану функцію один раз для кожного елемента в масиві. Параметром цього методу є function callback який приймає три аргуемнта (поточний елемент в масиві, індекс поточного елемента в масиві, масив який перебираєм) - обовязковим аргументом є лише перший


// const arr1 = [1, 2, 3, 4, 5, 6];  // створюєм новий масив

// function printItem (item, index, array){
//         console.log(`item[${index}] = ${item}`);
//         console.log(array);
// }; // оголошуємо функцію і вказуємо її параметри (поточний елемент, індекс поточного елем, масив)

// arr1.forEach(printItem); // передаємо функцію як аргумент. forEach пройдеться по кожному елементу застосовуючи до нього нашу функцію

// item[0] = 1
// (6) [1, 2, 3, 4, 5, 6]
//  item[1] = 2
//  (6) [1, 2, 3, 4, 5, 6]
//  item[2] = 3
//  (6) [1, 2, 3, 4, 5, 6]
//  item[3] = 4
//  (6) [1, 2, 3, 4, 5, 6]
//  item[4] = 5
//  (6) [1, 2, 3, 4, 5, 6]
//  item[5] = 6
//  (6) [1, 2, 3, 4, 5, 6]


// 2. map - створює новий масив з результатом виклику функції для кожного елемента іншого масива. Параметром цього методу є function callback який приймає три аргуемнта (поточний елемент в масиві, індекс поточного елемента в масиві, масив який перебираєм) - обовязковим аргументом є лише перший. Щоразу коли виконується колбек, значення яке повертається додається в новий масив

//згенерувати масив чисел піднесених до квадрату

// const arr1 = [1, 2, 3, 4, 5, 6];

// function toSqr(item, index, array) {  // тут ми не використали в тілі функції два останні параметри тому їх можна видалити
//         return item ** 2;
// };

// const arr1Mapped = arr1.map(toSqr);
// console.log(arr1Mapped);  // (6) [1, 4, 9, 16, 25, 36]  - отримуємо новий масив з елементами підннесеними в квадрат з попереднього масива, попередній масив залишається без змін


// отримати елементи з вихідного, змінивши значки елементам на від'ємні

// function toNegativeNum(item, index, array) {
//         return - item;
// };
// const arr2Mapped = arr1.map(toNegativeNum);
// console.log(arr2Mapped);


// отримати масив з іменами користувачів. Отримати Не амсив об'єктів а отримати масив імен!

// const users = [
//         {id: 1, name: 'Vasya'},
//         {id: 2, name: 'Petya'}
// ];

// function getName(user) {
//         return user.name;
// }

// const names = users.map(getName)
// console.log(names);  //(2) ['Vasya', 'Petya']



// 3. filter - створює новий масив з усіма елементами масиву, які пройшли перевірку, задану передаваною функцією. 
// Приймає параметр фунцкію-предикат, яка буде викликана для кожного елемента масива. Якщо йункція повертає true то елемент залишається в масиві, якщо false то видаєляється з нього  
// функція-предикат - це функція яка повертає true або false


// Отримати всі не парні чиссла з масиву в  новий масив
// const arr2 = [1, 5, -10, 0, 9, 16, 2];

// function isOdd(item) {
//         return item % 2 === 1;
//         // return item % 2 === 1 ? true : false;  - так розписувати немає сенсу, якщо тру то або якщо нє то фолс. Умовами методу це вже передбачено, тому достатньо самого виразу
// }

// const arr2Odd = arr2.filter(isOdd);
// console.log(arr2Odd); // (3) [1, 5, 9]


// Отримати повнолітніх юзерів з масиву обєктів

// const users = [
//         {id: 1, name: 'Vasya', age: 15},
//         {id: 2, name: 'Petya', age: 28},
//         {id: 3, name: 'Anna', age: 6},
//         {id: 4, name: 'Yulia', age: 18}
// ];


// function isAdult(user) {
//         return user.age >= 18;
// }

// const adultUsers = users.filter(isAdult);
// console.log(adultUsers);

// (2) [{…}, {…}]
// 0: {id: 2, name: 'Petya', age: 28}
// 1: {id: 4, name: 'Yulia', age: 18}
// length: 2
// [[Prototype]]: Array(0)



// findIndex - повертає індекс в масиві, якщо елеемент відповідає умові перевіряючої функції. в Іншому випадку повертає -1
// для методу findIndex callback викликається один раз для кожного елемента присутнього в масиві, до тих пір поки не повернеться true. Якщо такий елемент знайдено, метод findIndex одразу поверне індекс цього елемента в інщому випадку метод поверне 1-
// тут колбек теж приймає три аргумента (значення елемента, індекс елемента, масив) 


//Отримати індекс числа 16
// const arr2 = [1, 5, -10, 0, 9, 16, 2];

// function isSixteen (item) {
//         return item === 16;
// }

// const foundIndex = arr2.findIndex(isSixteen);
// console.log(foundIndex); // 5

// arr2.splice(foundIndex, 1); // видаляємо з масиву знайдений за допомогою findIndex елемент splice(той індекс який ми отримали за допомогою foundIndex, один елемент)
// console.log(arr2); // (6) [1, 5, -10, 0, 9, 2]



// Методів перебору масиву багато, синтаксис, набір параметрів майже однаковий у всіх, відрізняються вони тим як саме відпрацьовує в них колбек і що саме повертає метод
// forEach - не виконує нічого, лише те що в середині колбека 
// map - формує новий масив і передає туди всі елементи якимсь чином перетворені
// filter - формує новий масив з відфільтрованих елементів іншого масиву (тобто елементи які true)
// findIndex - просто повератає індекс елементу масиву відібраного за якимись ознаками, і далі ми повернуте знанчення перевикористовуєм ще для чогось